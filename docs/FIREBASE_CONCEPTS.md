# SQL 개발자를 위한 Firebase 개념 가이드

이 가이드는 SQL(관계형 데이터베이스)에 익숙한 개발자가 Firebase(특히 **Firestore**)라는 NoSQL 문서형 데이터베이스를 이해하는 데 도움을 주기 위해 작성되었습니다.

## 1. 사고방식의 전환 (Mental Model Shift)

### SQL: "엑셀 시트" 모델

SQL에서는 **테이블(Table)** 단위로 생각합니다.

- 데이터베이스는 하나의 엑셀 파일(Workbook)과 같습니다.
- **테이블(Table)**은 엑셀 시트(Sheet)와 같습니다 (예: `Users` 시트).
- **행(Row)**은 한 줄의 데이터 레코드입니다.
- **열(Column)**은 모든 행이 반드시 가져야 하는 속성입니다 (값이 없으면 NULL).
- **관계(Relationship)**는 외래 키(Foreign Key)와 `JOIN`으로 정의됩니다.

### Firestore: "JSON 폴더" 모델

Firestore에서는 **컬렉션(Collection)**과 **문서(Document)** 단위로 생각합니다.

- 데이터베이스는 하드 드라이브와 같습니다.
- **컬렉션(Collection)**은 **폴더**와 같습니다 (예: `Users` 폴더).
- **문서(Document)**는 그 폴더 안의 **JSON 파일**과 같습니다 (예: `user_123.json`).
- **필드(Field)**는 그 JSON 파일 안의 키-값 쌍입니다.
- **서브컬렉션(Subcollection)**은 파일 _안에_ 있는 또 다른 폴더입니다 (예: `user_123/posts/`).

> **핵심 차이점**: SQL에서는 데이터를 넣기 전에 반드시 열(Column)을 정의해야 합니다(`CREATE TABLE`). 반면 Firestore에서는 그냥 파일(문서)을 만들고 원하는 데이터를 넣으면 됩니다. "스키마"는 단지 여러분이 작성하기로 결정한 데이터 구조일 뿐입니다.

## 2. 핵심 개념 매핑 (Core Concepts Mapping)

| 개념         | SQL (관계형)          | Firestore (NoSQL)               | 비고                                                         |
| :----------- | :-------------------- | :------------------------------ | :----------------------------------------------------------- |
| **컨테이너** | 테이블 (Table)        | **컬렉션 (Collection)**         | 비슷한 레코드들의 그룹입니다.                                |
| **레코드**   | 행 (Row)              | **문서 (Document)**             | 하나의 아이템입니다. 필드와 값을 포함합니다.                 |
| **속성**     | 열 (Column)           | **필드 (Field)**                | 문서 내의 키-값 쌍입니다.                                    |
| **ID**       | 기본 키 (Primary Key) | **문서 ID (Document ID)**       | 문서를 식별하는 고유 값(문자열)입니다.                       |
| **관계**     | 외래 키 / JOIN        | **참조 (Reference) / 비정규화** | Firestore는 서버 사이드 JOIN을 지원하지 않습니다.            |
| **구조**     | 스키마 (엄격함)       | **스키마리스 (유연함)**         | 같은 컬렉션 내의 문서들도 서로 다른 필드를 가질 수 있습니다. |

## 3. 왜 "Create Table"이 없나요?

질문하신 내용: _"테이블 만들기 위한건 뭔데..?"_

SQL에서는:

```sql
-- 반드시 이것을 먼저 해야 합니다
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(50)
);
-- 그 다음에 데이터를 넣을 수 있습니다
INSERT INTO users VALUES (1, 'Alice');
```

Firestore에서는:

```javascript
// 그냥 이렇게 하면 됩니다.
// 'users' 컬렉션이 없으면, 자동으로 생성됩니다.
// 'user_1' 문서가 없으면, 자동으로 생성됩니다.
await setDoc(doc(db, "users", "user_1"), {
  name: "Alice",
});
```

**초기화 단계가 없습니다.** 데이터가 존재하면 구조도 존재하는 것입니다.

## 4. 실전에서의 주요 차이점

### 4.1. JOIN이 없음 (가장 어려운 부분)

SQL에서는 데이터를 정규화(테이블 분리)하고 `JOIN`으로 합칩니다.

- _쿼리_: "작성자 이름과 함께 모든 게시글 가져오기"
- _SQL_: `SELECT * FROM posts JOIN users ON posts.user_id = users.id`

Firestore에서는 서버에서 **JOIN이 비싸거나 불가능**합니다. 두 가지 선택지가 있습니다:

1.  **클라이언트 사이드 Join**: 게시글을 가져오고, 그 다음 작성자 정보를 가져옵니다 (요청 2번).
2.  **비정규화 (추천)**: `post` 문서 _안에_ `author_name`을 저장해버립니다.
    - _Post 문서_: `{ title: "안녕하세요", author_id: "u1", author_name: "Alice" }`
    - _트레이드오프_: Alice가 이름을 바꾸면, 그녀가 쓴 모든 글을 찾아서 업데이트해야 합니다. 하지만 읽기 속도는 엄청나게 빠릅니다.

### 4.2. 실시간 업데이트 (Real-time Updates)

SQL은 수동적입니다. 물어보면(SELECT) 대답합니다.
Firestore는 능동적입니다. **구독(Subscribe)**을 합니다 (`onSnapshot`).

- "이 `chats` 컬렉션이 변경될 때마다 알려줘."
- 서버가 변경사항을 클라이언트에게 즉시 밀어줍니다(Push). 채팅 앱이나 대시보드에 최적인 이유입니다.

### 4.3. 보안은 데이터베이스 안에

SQL에서는 백엔드 API(Node.js/Spring)가 쿼리를 실행하기 전에 로그인 여부를 확인합니다.
Firestore에서는 클라이언트가 종종 데이터베이스와 _직접_ 통신합니다.

- **보안 규칙** (`firestore.rules`)이 방화벽 역할을 합니다.
- _규칙 예시_: `allow read: if request.auth.uid == resource.data.owner_id;` (내 데이터만 읽을 수 있음)
- 이것이 많은 백엔드 코드를 대체합니다.

## 5. 요약: 왜 Firebase를 쓰나요?

| 장점                                                        | 단점                                                                                      |
| :---------------------------------------------------------- | :---------------------------------------------------------------------------------------- |
| **개발 속도**: 스키마 설정 불필요, 백엔드 코드 감소.        | **복잡한 쿼리**: "검색"이나 복잡한 필터링(예: "나이 > 20 OR 도시 = '서울'")이 어렵습니다. |
| **실시간성**: 내장 기능으로 제공됨 (WebSocket 코딩 불필요). | **데이터 모델링**: 성능 이슈를 피하기 위해 신중한 계획(비정규화 등)이 필요합니다.         |
| **확장성**: 대규모 트래픽을 자동으로 처리합니다.            | **벤더 종속성**: 표준 SQL보다 다른 곳으로 이전하기가 어렵습니다.                          |

**Stock Study 15-Day Tracker** 프로젝트의 경우:

- **실시간 업데이트**가 필요하므로 적합합니다 (예: 다른 멤버의 진도율을 즉시 확인).
- 데이터 구조가 계층적(스터디 -> Day -> 제출)이어서 **문서/서브컬렉션** 모델과 완벽하게 맞습니다.
